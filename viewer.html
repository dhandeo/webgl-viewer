<html> 
 
<head> 
<title>Connectome Viewer</title> 
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
 
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script> 
<script type="text/javascript" src="webgl-utils.js"></script> 
<script type="text/javascript" src="viewerCache.js"></script> 
<script type="text/javascript" src="viewerPath.js"></script> 
 
<script id="shader-fs" type="x-shader/x-fragment"> 
    #ifdef GL_ES
    precision highp float;
    #endif
 
    uniform sampler2D uSampler;
    uniform bool uUseTexture;
 
    varying vec2 vTextureCoord;
   
    void main(void) {
        if (uUseTexture) {
          gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        } else {
          gl_FragColor = vec4(0.0, 0.8, 1.0, 1.0);
        }
    }
</script> 
 
<script id="shader-vs" type="x-shader/x-vertex"> 
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
 
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    uniform bool uUseTexture;
 
    varying vec2 vTextureCoord;
 
    void main(void) {
        if (uUseTexture) {
          gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        } else {
          gl_Position = uPMatrix * vec4(aVertexPosition, 1.0);
        }
        vTextureCoord = aTextureCoord;
    }
</script> 
 
 
<script type="text/javascript"> 
 
    var gl;
 
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
 
 
    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }
 
        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }
 
        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }
 
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
 
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
 
        return shader;
    }
 
 
    function createProgram(fragmentShaderID, vertexShaderID) {
        var fragmentShader = getShader(gl, fragmentShaderID);
        var vertexShader = getShader(gl, vertexShaderID);
 
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
 
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
 
        program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
        gl.enableVertexAttribArray(program.vertexPositionAttribute);
 
        program.textureCoordAttribute = gl.getAttribLocation(program, "aTextureCoord");
        gl.enableVertexAttribArray(program.textureCoordAttribute);
 
        // Camera
        program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
        // Tile matrix
        program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
        // Texture
        program.samplerUniform = gl.getUniformLocation(program, "uSampler");
        // Hack to draw path with a single program/shader
        program.useTextureUniform = gl.getUniformLocation(program, "uUseTexture");

        return program;
    }
 

    var imageProgram;
    var pathProgram;

    function initShaders() {
        // this program works when defined by itself, but not with imageProgram.
        //pathProgram = createProgram("shader-pfs", "shader-pvs");
        imageProgram = createProgram("shader-fs", "shader-vs");
    }
 
 
    var PATH_COUNT = 0;
    var PATHS = [];
    var TILES = [];

    // Load the root tiles to make switching sections smoother.
    
    function loadRoots () {
        var qTile;
        for (var slice = 0; slice < 900; ++slice) {
          qTile = GetTile(slice, 0, 0);
          LoadQueueAdd(qTile);
          }
    }

    // Just for debugging.
    function initTiles () {
        var qTile;
        //qTile = new Tile(0,0,0, "http://paraviewweb.kitware.com:82/tile.py/daniels/1/t.jpg");
        //Tiles.push(qTile);
        //qTile = new Tile(0,1,1, "tq.jpg");
        //Tiles.push(qTile);
        //qTile = new Tile(1,1,1, "tr.jpg");
        //Tiles.push(qTile);
        //qTile = new Tile(1,0,1, "ts.jpg");
        //Tiles.push(qTile);
        //qTile = new Tile(0,0,1, "tt.jpg");
        //Tiles.push(qTile);
    
    
        qTile = GetTile(1, 1, 0);
        Tiles.push(qTile);
        //qTile = GetTile(1, 1, 3);
        //Tiles.push(qTile);
    
        qTile = GetTile(1, 3, 2+(2*8));
        Tiles.push(qTile);
    
        qTile = GetTile(1, 2, 6);
        Tiles.push(qTile);
        qTile = GetTile(1, 2, 9);
        Tiles.push(qTile);
        qTile = GetTile(1, 2, 10);
        Tiles.push(qTile);
    }
    

    var CAMERA;
    var SLICE = 1;

 
 
    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
 
 
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;
 
    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }
 
 
    function handleMouseUp(event) {
        mouseDown = false;
    }
 
    var MOUSE_X;
    var MOUSE_Y;

    function handleMouseMove(event) {
        MOUSE_X = event.clientX;
        MOUSE_Y = event.clientY;

        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;
 
        var deltaX = lastMouseX - newX
        var deltaY = newY - lastMouseY;
        
        deltaX = deltaX * CAMERA.GetWidth() / gl.viewportHeight
        deltaY = deltaY * CAMERA.GetHeight() / gl.viewportHeight
        
        CAMERA.Translate(deltaX, deltaY, 0.0);
        TILES = ChooseTiles(CAMERA, SLICE, TILES);

        lastMouseX = newX
        lastMouseY = newY;
    }
 
//------------- Keys ---------------

    var zoomTarget;
    var zoomAnimateLast;
    var zoomAnimateDuration;
    var P_KEY_PRESSED = false;

    function handleKeyDown(event) { 
        if (String.fromCharCode(event.keyCode) == "P") {
          P_KEY_PRESSED = true;
        }
        if (String.fromCharCode(event.keyCode) == "R") {
          CAMERA.Reset();
          zoomTarget = CAMERA.GetHeight();
        }
        if (event.keyCode == 33) {
          // PageUp
          zoomTarget *= 2;
          zoomAnimateLast = new Date().getTime();
          zoomAnimateDuration = 200.0;
        }
        if (event.keyCode == 34) {
          // PageDown 
          zoomTarget *= 0.5;
          zoomAnimateLast = new Date().getTime();
          zoomAnimateDuration = 200.0;
        }
        if (event.keyCode == 37) {
          // Left cursor key
          if (SLICE > 1) {
             CAMERA.Translate(0,0,-ROOT_SPACING[2]);
            --SLICE;
            TILES = ChooseTiles(CAMERA, SLICE, TILES);
          }
        } else if (event.keyCode == 39) {
          // Right cursor key
          if (P_KEY_PRESSED) {
            ++PATH_COUNT;
            PATHS[PATH_COUNT] = new Path();
            PATHS[PATH_COUNT].Copy(PATHS[PATH_COUNT-1]);
            PATHS[PATH_COUNT].Advance(MOUSE_X, MOUSE_Y, CAMERA);
            // This did not help.
            //gl.deleteBuffer(PATHS[PATH_COUNT-1].Buffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, PATHS[PATH_COUNT-1].Buffer);
    gl.bufferData(gl.ARRAY_BUFFER, null, 
                  gl.STATIC_DRAW);
            PATHS[PATH_COUNT].CreateBuffer();
          }
          ++SLICE;
          CAMERA.Translate(0,0,ROOT_SPACING[2]);
          TILES = ChooseTiles(CAMERA, SLICE, TILES);
        }
 
        if (event.keyCode == 38) {
          // Up cursor key
          zoomTarget *= 2;
          zoomAnimateLast = new Date().getTime();
          zoomAnimateDuration = 200.0;
        } else if (event.keyCode == 40) {
          // Down cursor key
          if (zoomTarget > 0.9 / (1 << 5)) {
            zoomTarget *= 0.5;
            zoomAnimateLast = new Date().getTime();
            zoomAnimateDuration = 200.0;
          }
        }
    }


    function handleKeyUp(event) {
        if (String.fromCharCode(event.keyCode) == "P") {
          P_KEY_PRESSED = event;
        }
    }

    function animateZoom() {
      if (CAMERA.GetHeight() != zoomTarget) {
        var timeNow = new Date().getTime();
        if (timeNow > (zoomAnimateLast + zoomAnimateDuration)) {
          CAMERA.Height = zoomTarget;
        } 
        else {
          var current = CAMERA.GetHeight();
          CAMERA.Height = current + (zoomTarget-current)*(timeNow-zoomAnimateLast)/zoomAnimateDuration;
        }
        CAMERA.ComputeMatrix();
        TILES = ChooseTiles(CAMERA, SLICE, TILES);
        zoomAnimateDuration -= (timeNow-zoomAnimateLast);
        zoomAnimateLast = timeNow;  
      }
    }    

    var tileVertexPositionBuffer;
    var tileVertexTextureCoordBuffer;
    var tileCellBuffer;
 
    function initBuffers() {
        var vertexPositionData = [];
        var textureCoordData = [];

        // Make 4 points
        textureCoordData.push(0.0);
        textureCoordData.push(0.0);
        vertexPositionData.push(0.0);
        vertexPositionData.push(0.0);
        vertexPositionData.push(0.0);

        textureCoordData.push(1.0);
        textureCoordData.push(0.0);
        vertexPositionData.push(1.0);
        vertexPositionData.push(0.0);
        vertexPositionData.push(0.0);

        textureCoordData.push(0.0);
        textureCoordData.push(1.0);
        vertexPositionData.push(0.0);
        vertexPositionData.push(1.0);
        vertexPositionData.push(0.0);

        textureCoordData.push(1.0);
        textureCoordData.push(1.0);
        vertexPositionData.push(1.0);
        vertexPositionData.push(1.0);
        vertexPositionData.push(0.0);

        // Now create the cell.
 
        var cellData = [];
        cellData.push(0);
        cellData.push(1);
        cellData.push(2);
 
        cellData.push(2);
        cellData.push(1);
        cellData.push(3);
 
        tileVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tileVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
        tileVertexTextureCoordBuffer.itemSize = 2;
        tileVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;
 
        tileVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tileVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
        tileVertexPositionBuffer.itemSize = 3;
        tileVertexPositionBuffer.numItems = vertexPositionData.length / 3;
 
        tileCellBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tileCellBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), gl.STATIC_DRAW);
        tileCellBuffer.itemSize = 1;
        tileCellBuffer.numItems = cellData.length;

        //PathInitBuffers();
    }
 
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        var program = imageProgram;
        gl.useProgram(program);

        var perspective = ! document.getElementById("perspective").checked;
        if (perspective) {
          CAMERA.SetRotation(CAMERA.Rotation + 0.01);
	}
        gl.uniformMatrix4fv(program.pMatrixUniform, false, CAMERA.Matrix);

        // Draw Path
        gl.uniform1i(program.useTextureUniform, false);
        //PATHS[PATH_COUNT].Draw(program);
        PATHS[1].Draw(program);
        PATHS[0].Draw(program);

        // Draw Tiles ----------------------------------
        gl.useProgram(program);

        gl.uniform1i(program.useTextureUniform, true);

        // These are the same for every tile.
        // Vertex points (shifted by tiles matrix)
        gl.bindBuffer(gl.ARRAY_BUFFER, tileVertexPositionBuffer);
        gl.vertexAttribPointer(program.vertexPositionAttribute, tileVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        // Texture coordinates
        gl.bindBuffer(gl.ARRAY_BUFFER, tileVertexTextureCoordBuffer);
        gl.vertexAttribPointer(program.textureCoordAttribute, tileVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
        // Cell Connectivity
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tileCellBuffer);

        for (var i = 0; i < TILES.length; ++i) {
          TILES[i].Draw(program);
        }
    }
 
    function tick() {
        requestAnimFrame(tick);
        animateZoom();
        drawScene();
    }
 
 
    function webGLStart() {
        var canvas = document.getElementById("lesson11-canvas");
        initGL(canvas);
        initShaders();
        initBuffers();
        //initTiles(); // For debugging
        loadRoots();
        CAMERA = new Camera(gl.viewportWidth, gl.viewportHeight);
        zoomTarget = CAMERA.GetHeight();
        TILES = ChooseTiles(CAMERA, SLICE, TILES);

	PATHS[0] = new Path();
        PATHS[0].AddPoint(8000,  0.0,  0);
        PATHS[0].AddPoint(8000,  8000, 0);
        PATHS[0].AddPoint(8000,  8000,  8000);
        PATHS[0].AddPoint(8000,  16000,  8000);
        PATHS[0].CreateBuffer();

	PATHS[1] = new Path();
        PATHS[1].AddPoint(3000,  0.0,  0);
        PATHS[1].AddPoint(3000,  8000, 0);
        PATHS[1].AddPoint(3000,  8000,  8000);
        PATHS[1].AddPoint(3000,  16000,  8000);
        // This breaks the path rendering.  Why?  Different number of points?
        //PATHS[1].AddPoint(3000,  5000,  5000);
        PATHS[1].CreateBuffer();

	//PATHS[1] = new Path();
        //PATHS[1].AddPoint(3000,  3000, 0);
        //PATHS[1].AddPoint(5000,  3000, 0);
        //PATHS[1].AddPoint(5000,  5000, 0);
        //PATHS[1].AddPoint(3000,  5000, 0);
        //PATHS[1].AddPoint(3000,  3000, 0);
        //PATHS[1].CreateBuffer();

        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
 
        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
 
        tick();
    }
 
</script> 
 
 
</head> 
 
 
<body onload="webGLStart();"> 
    <a href="http://learningwebgl.com/blog/?p=1253">&lt;&lt; Back to Lesson 11</a><br /> 
 
    <canvas id="lesson11-canvas" style="border: none;" width="900" height="600"></canvas> 
    <br/> 
 
    <input type="checkbox" id="perspective" checked /> Perspective <br/> 
    Pan the image by dragging it with the mouse.
    <br/> 
 
    <h2>Directional light:</h2> 
 
    <table style="border: 0; padding: 10px;"> 
        <tr> 
            <td><b>Direction:</b> 
            <td>X: <input type="text" id="lightDirectionX" value="-1.0" /> 
            <td>Y: <input type="text" id="lightDirectionY" value="-1.0" /> 
            <td>Z: <input type="text" id="lightDirectionZ" value="-1.0" /> 
        </tr> 
        <tr> 
            <td><b>Colour:</b> 
            <td>R: <input type="text" id="directionalR" value="0.8" /> 
            <td>G: <input type="text" id="directionalG" value="0.8" /> 
            <td>B: <input type="text" id="directionalB" value="0.8" /> 
        </tr> 
    </table> 
 
 
    <h2>Ambient light:</h2> 
 
    <table style="border: 0; padding: 10px;"> 
        <tr> 
            <td><b>Colour:</b> 
            <td>R: <input type="text" id="ambientR" value="0.2" /> 
            <td>G: <input type="text" id="ambientG" value="0.2" /> 
            <td>B: <input type="text" id="ambientB" value="0.2" /> 
        </tr> 
    </table> 
    <br/> 
    <br/> 
    <br/> 
 

</body> 
 
</html> 
